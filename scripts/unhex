#!/usr/bin/env python3
import sys
import binascii
import struct
import encodings
import pathlib
import argparse

p = argparse.ArgumentParser()
p.add_argument("-a", "--all-encodings", action="store_true", help="check all encodings")
p.add_argument("hex", nargs="+")
args = p.parse_args()


if args.all_encodings:
	encs = []
	for e in pathlib.Path(encodings.__file__).parent.iterdir():
		try: mod = __import__("encodings." + e.stem, fromlist=["*"])
		except ImportError: continue

		try: info = mod.getregentry()
		except AttributeError: continue

		if not info._is_text_encoding: continue
		if info.name == "undefined": continue

		encs.append(info.name)
	encs.sort(key=lambda k: (k.startswith("iso") or k.startswith("cp"), k))
else:
	encs = ["ascii", "latin1", "utf-8", "sjis", "cp932", "gbk"]

a = bytearray()
for arg in args.hex:
	try:
		a.extend(binascii.a2b_hex(arg))
	except Exception as e:
		print(e, file=sys.stderr)
		sys.exit(1)

if not a:
	print("Input is empty", file=sys.stderr)
	sys.exit()

seen = set()
for e in encs:
	try:
		s = a.decode(e)
	except UnicodeError:
		try: s = a.decode(e, errors="replace")
		except: continue
	s = "".join(s if s.isprintable() else "�" for s in s)
	if s.count("�") / len(s) < 0.3 and s not in seen:
		print(e, "=", s)
		seen.add(s)

if len(a) <= 8:
	leu = int.from_bytes(a, "little")
	les = int.from_bytes(a, "little", signed=True)
	beu = int.from_bytes(a, "big")
	bes = int.from_bytes(a, "big", signed=True)
	print("LE", "=", f"{leu} ({les})" if leu != les else leu)
	print("BE", "=", f"{beu} ({bes})" if beu != bes else beu)
if len(a) == 4:
	print("LE float", "=", struct.unpack("<f", a)[0])
	print("BE float", "=", struct.unpack(">f", a)[0])
if len(a) == 8:
	print("LE double", "=", struct.unpack("<d", a)[0])
	print("BE double", "=", struct.unpack(">d", a)[0])
