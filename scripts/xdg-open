#!/usr/bin/env python3
import os
import os.path
import argparse
from fnmatch import fnmatch
import stat
from collections import defaultdict
import subprocess
import appdirs

#{{{1 Largely inspired from xdg.mime
XDG_HOME = os.environ.get("XDG_DATA_HOME", os.path.expanduser("~/.local/share"))
XDG_DATA_DIRS = os.environ.get("XDG_DATA_DIRS", "/usr/local/share:/usr/share").split(":")

def getFiles(name):
	ret = []
	for dir in [XDG_HOME] + XDG_DATA_DIRS:
		path = os.path.join(dir, name)
		if os.path.exists(path) and path not in ret:
			ret.append(path)
	return ret

TEXT_CHARS = bytes([7, 8, 9, 10, 12, 13, 27] + list(range(0x20, 0x100)))
def isBinaryString(bytes):
	return bool(bytes.translate(None, TEXT_CHARS))

ALIASES = defaultdict(lambda: None)
for path in getFiles("mime/aliases"):
	with open(path, "r") as file:
		for line in file:
			if line.endswith("\n"):
				line = line[:-1]

			mime, alias = line.split(" ")
			ALIASES[mime] = alias

ICONS = defaultdict(lambda: None)
for path in getFiles("mime/generic-icons"):
	with open(path, "r") as file:
		for line in file:
			if line.endswith("\n"):
				line = line[:-1]

			mime, icon = line.split(":")
			ICONS[mime] = icon

SUBCLASSES = defaultdict(list)
for path in getFiles("mime/subclasses"):
	with open(path, "r") as file:
		for line in file:
			if line.endswith("\n"):
				line = line[:-1]

			mime, subclass = line.split(" ")
			if subclass not in SUBCLASSES[mime]:
				SUBCLASSES[mime].append(subclass)

GLOB_EXTENSIONS = defaultdict(list)
GLOB_LITERALS = {}
GLOB_MATCHES = [] # (Weight, mime, glob, flags)
for path in getFiles("mime/globs2"):
		with open(path, "r") as file:
			for line in file:
				if line.startswith("#"): continue
				if line.endswith("\n"): line = line[:-1]

				[weight, mime, glob, flags, *_] = line.split(":") + [""]
				flags = flags.split(",")

				if "*" not in glob and "?" not in glob and "[" not in glob:
					GLOB_LITERALS[glob] = mime
				elif glob.startswith("*.") and "cs" not in flags:
					extension = glob[1:]
					if "*" not in extension and "?" not in extension and "[" not in extension:
						GLOB_EXTENSIONS[extension].append((int(weight), mime))
				else:
					GLOB_MATCHES.append((int(weight), mime, glob, flags))

class P: # Very simple binary parser/reader with one byte readahead
	def __init__(self, file):
		self._file = file
		self._peek = None
		self._i = 0

	def peek(self):
		if self._peek is None:
			self._peek = self._file.read(1)
		return self._peek

	def get(self):
		self._i += 1
		if self._peek is not None:
			a = self._peek
			self._peek = None
			return a
		return self._file.read(1)[0]

	def gets(self, len):
		return bytes(self.get() for _ in range(len))

	def test(self, c):
		if self.peek() == c:
			self.get()
			return True
		return False

	def num(self):
		ret = bytearray()
		while self.peek().isdigit():
			ret.append(self.get()[0])
		return int(ret)

class MagicRule(object):
	def __init__(self, p):
		self.next = None

		self.nest = 0
		self.startOffset = None
		self.value = None
		self.mask = None
		self.wordSize = 1
		self.rangeLength = 1

		if p.peek() != b">": self.nest = p.num()
		if p.test(b">"): self.startOffset = p.num()
		if p.test(b"="): self.value = p.gets(p.get() << 8 | p.get())
		if p.test(b"&"): self.mask = p.gets(len(self.value))
		if p.test(b"~"): self.wordSize = p.num()
		if p.test(b"+"): self.rangeLength = p.num()

		if self.startOffset is None: raise ValueError("No offset for magic line")
		if self.value is None: raise ValueError("No value for magic line")
		if not p.test(b"\n"): raise ValueError("Malformed MIME magic line: %r" % p.peek())

	def match(self, buffer):
		for o in range(self.rangeLength):
			s = self.startOffset + o
			if self.mask: test = bytes([a & b for (a, b) in zip(buffer[s:], self.mask)])
			else: test = buffer[s:s+len(self.value)]
			if test == self.value:
				if self.next:
					return self.next.match(buffer)
				return True

MAGIC_TYPES = {}
MAGIC_MAXLEN = 0
for path in getFiles("mime/magic"):
	with open(path, "rb") as file:
		if file.read(12) != b"MIME-Magic\0\n":
			raise ValueError("Bad header for file %r" % path)
		p = P(file)

		while p.peek():
			if not p.test(b"["): raise ValueError("Expected heading opening, found %r" % p.peek())
			pri = p.num()
			if not p.test(b":"): raise ValueError("Expected heading colon, found %r" % p.peek())
			mimeB = bytearray()
			while not p.test(b"]"):
				mimeB.append(p.get()[0])
			mime = bytes(mimeB).decode()
			if not p.test(b"\n"): raise ValueError("Expected heading newline, found %r" % p.peek())

			topRules = []
			lastRule = None
			while p.peek() and p.peek() != b"[":
				rule = MagicRule(p)

				if rule.nest != 0 and lastRule:
					if rule.nest < lastRule.nest:
						lastRule.next = rule
				else:
					topRules.append(rule)
					lastRule = rule # Should this be unindented?

				length = rule.startOffset + len(rule.value) + rule.rangeLength
				if length > MAGIC_MAXLEN:
					MAGIC_MAXLEN = length

			if pri not in MAGIC_TYPES:
				MAGIC_TYPES[pri] = []
			MAGIC_TYPES[pri].append((mime, topRules))
#}}}1

def match_globs(path):
	name = os.path.basename(path)
	if name in GLOB_LITERALS:
		return [GLOB_LITERALS[name]]
	if name.lower() in GLOB_LITERALS:
		return [GLOB_LITERALS[name.lower()]]

	ext = os.path.splitext(name)[1]
	matches = None
	if ext in GLOB_EXTENSIONS:
		matches = GLOB_EXTENSIONS[ext]
	elif ext.lower() in GLOB_EXTENSIONS:
		matches = GLOB_EXTENSIONS[ext.lower()]
	else:
		matches = []
		for w, m, g, f in GLOB_MATCHES:
			if fnmatch(name, g) or ("cs" not in f and fnmatch(name.lower(), g)):
				matches.append((w + len(g) / 128, m))
	return sorted(matches, reverse=True)

def match_magic(f):
	data = open(f, "rb").read(MAGIC_MAXLEN)
	matches = []
	for priority in MAGIC_TYPES.keys():
		for (mime, rules) in MAGIC_TYPES[priority]:
			for rule in rules:
				if rule.match(data):
					matches.append((priority, mime))
	return sorted(matches, reverse=True)

def match_inode(path):
	try:
		mode = os.stat(path).st_mode
	except IOError:
		return

	if os.path.ismount(path): return "inode/mount-point"
	if stat.S_ISBLK(mode):    return "inode/blockdevice"
	if stat.S_ISCHR(mode):    return "inode/chardevice"
	if stat.S_ISDIR(mode):    return "inode/directory"
	if stat.S_ISFIFO(mode):   return "inode/fifo"
	if stat.S_ISLNK(mode):    return "inode/symlink"
	if stat.S_ISSOCK(mode):   return "inode/socket"

def match_basic(path):
	data = open(path, "rb").read(1024)
	if not data:
		return "inode/x-empty"
	elif not isBinaryString(data):
		return "text/plain"
	else:
		return "application/octet-stream"

def match(path):
	try: glob = match_globs(path)
	except OSError: glob = []
	try: magic = match_magic(path)
	except OSError: magic = []
	try: inode = match_inode(path)
	except OSError: inode = None
	try: basic = match_basic(path)
	except OSError: basic = None

	inode_   = [inode] if inode else []
	magic_hi = [m[1] for m in magic if m[0] >= 80]
	glob_    = [m[1] for m in glob]
	magic_lo = [m[1] for m in magic if m[0] < 80]
	basic_   = [basic]
	return inode_ + magic_hi + glob_ + magic_lo + basic_

argp = argparse.ArgumentParser()
argp.add_argument("-n", "--dry-run", action="store_true")
argp.add_argument("-s", "--sync", action="store_true")
argp.add_argument("file")
args = argp.parse_args()

f = args.file # type: str
if f.startswith("file://"):
	f = f[7:] # TODO escaping and stuff

if ':' in f:
	mime = ["x-scheme-handler/" + f.split(":", 1)[0]]
else:
	mime = match(f)

run = {}
with open(appdirs.user_config_dir("mime.cfg")) as mimelist:
	cmd = None
	for line in mimelist.read().splitlines():
		if line == line.lstrip():
			cmd = line.split()
			for i, word in enumerate(cmd):
				if word == "%":
					cmd[i] = f
				elif word[:1] == "$":
					cmd[i] = os.environ[word[1:]]
		else:
			run[line.lstrip()] = cmd

def nub(seq):
	return list(dict.fromkeys(seq)) # Only works in 3.6

def first(seq):
	try:
		return next(item for item in seq if item is not None)
	except StopIteration:
		return None

checked = []
def check(mime):
	checked.append(mime)
	return run.get(mime)

def get(mime):
	if mime is None:
		return None
	type = mime.split("/")[0]
	return first([
		check(mime),
		check("%s/*" % type),
		check("@%s" % ICONS.get(mime, "%s-x-generic" % type)),
		get(ALIASES[mime]),
		first([get(m) for m in SUBCLASSES[mime]]),
	])


print(f"Opening '{f}'")
cmd = first([get(m) for m in mime])
print("Possible mime types:")
for m in nub(mime):
	print(" ", m)
print("Checked keys:")
for m in nub(checked):
	print(" ", m)
print("Command:")
print(" ", cmd)

if not args.dry_run:
	if cmd:
		subprocess.Popen(["notify-send", f"Opening '{cmd[0]}'", f])
	else:
		cmd = ["notify-send", "Don't know how to handle %s file" % checked, f]


	if args.sync:
		os.execlp(*cmd)
	else:
		subprocess.Popen(cmd)
